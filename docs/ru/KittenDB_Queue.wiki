<i>KittenDB Queue</i> -- предназначен для получения обновлений чего-либо в
реальном времени. Движок поддерживает добавление в очередь новых событий,
подписку очередей на новые события других очередей с автоматическим их
перенаправлением при добавлении во все заинтересованные очереди, а также
получение из очереди всех событий, произошедших после определённого момента.

Название очереди - строка, состоящая из букв латинского алфавита, цифр и
символа '_' длиной до 24 символов, которая не может начинаться с "w_" или "n_".

Один из примеров применения -- обновление счетчиков на странице. Когда
пользователю приходит новое сообщение, в очередь пользователя записывается
соответствующее событие, в котором указано новое значение счетчика сообщений.
Если же пользователю нужно в реальном времени получать обновление своей
ленты новостей, то необходимо подписать очередь пользователя на получение
обновлений исходящих очередей всех, на кого он подписан.

Пользователь получает обновления нужных очередей через http long poll запрос.
Для этого он должен подписаться на соответствующие очереди, получив их
секретный ключ и timestamp, обозначающий позицию в очереди. У ключа есть время
жизни, в течение которого он будет давать доступ к очереди после последнего
удачного запроса. Соответственно, если ключом не пользуются слишком долго, то
он перестаёт давать доступ к очереди. Для получении обновлений требуется
указать ключ и timestamp. Результатом будет или список событий с указанием
нового timestamp, сообщение о том, что новых данных нет, либо сообщение об
ошибке (например, ключ истёк, некорректен, выдан другому пользователю, либо
у пользователя существеенно изменился ip-адрес).

На данный момент timestamp не несет ни какой смысловой нагрузки, но при запросе
должен совпадать с предыдущим полученным timestamp-ом.

== Интерфейс ==
Движок поддерживает memcached интерфейс.

== Добавление в очередь ==
<code>add("queue[{$x},{$y}]({$qname})", $event)</code>
<br>
Добавляет строку $event в очередь с названием $qname.
<br>
<code>$x, $y</code> используются для проверки приватностей при пересылке
сообщения, по умолчанию <code>$x = $y = 0</code>. Чтобы сообщение переслалось
должно быть выполнено условие <code>($x & $flag) == $y</code>, где
<code>$flag</code> - флаг, с которым произведена подписка (см. ниже).

== Получение обновлений из очереди ==
<code>get("queue{$id},{$ip},{$timestamp_old}({$key})")</code>
<br>
Запрос аналогичный HTTP-запросу a_check. Единственное отличие -- ответ
возвращается сразу.

== Получение текущего timestamp-а и ключа ==
<code>get("timestamp_key{$id},{$ip},{$timeout}({$qname})")</code>
<br>
Возвращает текущий timestamp и key для идентификации очереди с именем
<code>$qname</code> для пользователя <code>$id</code> с ip-адресом
<code>$ip</code> в формате JSON в виде объекта с полями ts и key.
<br>
<code>timestamp</code> - строчка длиной от одного до 18-ти символов, состоящая
из цифр,
<br>
<code>key</code> - строка длиной 56 символов, состоящая из букв латинского
алфавита, цифр и знака подчёркивания.

== Сброс ключей для данного пользователя ==
<code>get("upd_secret{$id}")</code>
<br>
После выполнения этого запроса все ключи на данный момент полученные для
пользователя <code>id</code> становятся недействительными. Необходимо
использовать, например, в случае смены пароля или разлогинивания пользователя.

== Сброс ключей для данной очереди ==
<code>get("upd_secret_qname({$qname})")</code>
<br>
После выполнения этого запроса все ключи на данный момент полученные для
очереди <code>qname</code> становятся недействительными для всех пользователей. Можно использовать если нужно
выкинуть только из данной очереди всех пользователей.

== Получение псевдонима очереди ==
Чтобы подписать одну очередь на другую следует использовать псевдонимы.
<br>
<code>get("alias({$qname})")</code>
<br>
Результат -- псевдоним, 63 битное целое положительное число.
<b>С течением времени псевдоним для очереди с одним и тем же названием может
меняться.</b>

== Получение псевдонима очереди новостей ==
<code>get("alias_news({$uid})")</code>
<br>
Чтобы подписаться на новости другого человека, следует создать очередь,
подписанную на полученный alias.


== Queue и News ==
=== Получение ключа на очередь, содержащую новости данного человека ===
<code>get("news_key{$id},{$ip},{$timeout}($uid)")</code>
<br>
Возвращает ключ на очередь, в которую будут приходить новости пользователя
<code>$uid</code>.

=== Установить подписки пользователя или очереди ===
<code>set("subscr{$uid}", "{$id_1},{$flag_1},{$id_2},{$flag_2},...,{$id_n},{$flag_n}")</code>
<br>
Эту команду требуется выполнять перед каждым получение ключа на очередь
новостей.
<code>$uid</code> будет подписан на новости от пользователей. <code>$uid</code> может быть как
идентификатором пользователя, так и псевдонимом очереди.
<code>{$id_i}</code> с флагами <code>{$flag_i}</code>.

=== Добавить в подписки пользователя или очереди ===
<code>set("subscr_add{$uid}", "{$id_1},{$flag_1},{$id_2},{$flag_2},...,{$id_n},{$flag_n}")</code>

=== Удалить из подписок пользователя или очереди ===
<code>set("subscr_del{$uid}", "{$id_1},{$id_2},...,{$id_n}")</code>

=== Отправить новость ===
<code>set("news{$uid},{$x},{$y}", {$text})</code>
<br>
<code>$x, $y</code> используются для проверки приватностей при пересылке
сообщения. Чтобы сообщение переслалось должно быть выполнено условие
<code>($x & $flag) == $y</code>, где <code>$flag</code> - флаг, с которым
произведена подписка.

== Queue и Watchcat ==
Движок ''KittenDB Watchcat'' позволяет в режиме реального времени выполнять
поисковые запросы по новым постам в микроблоге. Для этого текст всех новых
постов должен передаваться Watchcat, который автоматически пересылает его
во все заинтересованные очереди.

=== Получение ключа watchcat-а ===
<code>get("watchcat_key{$id},{$ip},{$timeout}({$word_1}+{$word_2}+...{$word_n})")</code>
<br>
Возвращает ключ на очередь, в которую будут приходить записи, содержащие слова
<code>$word_1, ..., $word_n</code>.

=== Добавление новой записи в микроблоге в watchcat ===
<code>add("entry", "[{$search_data}\x01]{$entry_data}")</code>
<br>
Запрос сообщает watchcat-engine о новой записи в микроблоге.
<br>
<code>$search_data</code> - текст записи, который нужно учитывать при поиске,
<br>
<code>$entry_data</code> - данные, которые будут перенаправлены в queue.
Если <code>$search_data</code> отсутствует, то поиск будет произведён по
<code>$entry_data</code>.


== HTTP-интерфейс ==
Для получения обновлений через HTTP-интерфейс/разрыва соединения необходимо
отправить GET-запрос с параметрами
<br>
<code>act,key,ts,id,wait</code>.
<br>
<code>act</code> - тип выполняемого действия, а именно <code>a_check</code>
для получения обновлений или <code>a_release</code> для освобождения ключа.
<br>
<code>key</code> - секретный ключ, при помощи которого можно получать
обновления из очереди, или конкатенация нескольких таких ключей.
<br>
<code>ts</code> - timestamp, соответствующий ключу и полученный ранее из движка,
или конкатенация нескольких таких timestamp через символ '_'.
<br>
<code>id</code> - <code>id</code> пользователя. Должен совпадать с
<code>id</code>, передававшимся при получении ключа.
<br>
<code>wait</code> - максимальное время для удержания long poll запроса в случае
отсутствия новых событий, не обязательно при <code>act=a_release</code>.

Данные возвращаются в виде объекта JSON с полями <code>ts, events</code>, где
<br>
<code>ts</code> - текущий timestamp,
<br>
<code>events</code> - JSON-массив, состоящий из строк - описаний новых событий,
в том виде, в котором они были добавлены в движок, в хронологическом порядке.
Если событие начинается с символа '\x02', то оно будет выдано в точности в
переданном виде без этого символа и без конвертации в JSON-строку.

В случае возникновения ошибки при обработке запроса возвращается JSON-массив
следующего вида:
<br>
<code>{"failed":$code[,err":$err_code]}</code>, где <code>$code</code> - код
ошибки. Возможные его значения:
<br>
1 - Ошибка в запросе.
<br>
2 - Указан некорректный ключ или timestamp.

В случае failed:2 может быть указан более подробный код ошибки
<code>$err</code>:
<br>
1 - Не удалось расшифровать ключ.
<br>
2 - Не совпал id, ip или secret.
<br>
3 - Переданный ключ не найден.
<br>
4 - Ключ заблокирован другим http-запросом.
<br>
5 - Не совпал timestamp.

В случае, если было передано несколько ключей, то результат будет возвращён
в виде массива таких объектов.

=== Прерывание соединения с заданным ключом ===
В случае act=a_release, соединения на указанные ключи будут завершены.
